var documenterSearchIndex = {"docs":
[{"location":"couplingfunctions/#Spin-spin-interactions","page":"Spin-spin interactions","title":"Spin-spin interactions","text":"","category":"section"},{"location":"couplingfunctions/","page":"Spin-spin interactions","title":"Spin-spin interactions","text":"Nchain\nNNlattice","category":"page"},{"location":"couplingfunctions/#SpiDy.Nchain","page":"Spin-spin interactions","title":"SpiDy.Nchain","text":"Nchain(N, J0; boundary=nothing)\n\nCreate the spin-spin coupling matrix of a 1D chain of N sites with nearest-neighbour interactions of strength set by J0.\n\nArguments\n\nN: The number of sites in the chain.\nJ0: The nearest-neighbour coupling strength.\nboundary=nothing: (Optional) Specifies the boundary condition of the chain. Default is nothing which corresponds to a chain open at the edges. Use :periodic for periodic boundary conditions.\n\nReturns\n\nAn N×N array representing the coupling matrix.\n\nExamples\n\njulia> J = Nchain(4, 2.0)\n4×4 Matrix{Float64}:\n 0.0  2.0  0.0  0.0\n 2.0  0.0  2.0  0.0\n 0.0  2.0  0.0  2.0\n 0.0  0.0  2.0  0.0\n\njulia> J_periodic = Nchain(4, 2.0; boundary=:periodic)\n4×4 Matrix{Float64}:\n 0.0  2.0  0.0  2.0\n 2.0  0.0  2.0  0.0\n 0.0  2.0  0.0  2.0\n 2.0  0.0  2.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"couplingfunctions/#SpiDy.NNlattice","page":"Spin-spin interactions","title":"SpiDy.NNlattice","text":"NNlattice(N, Jh, Jv; boundary=nothing)\n\nCreate the spin-spin coupling matrix of a NxN 2D lattice with nearest-neighbour interactions and specified horizontal and vertical coupling strengths, Jh and Jv respectively.\n\nArguments\n\nN: The size of the lattice (N x N).\nJh: The horizontal nearest-neighbour coupling strength.\nJv: The vertical nearest-neighbour coupling strength.\nboundary=nothing: (Optional) Specifies the boundary condition of the lattice. Default is nothing which corresponds to open edges. Use :periodic for periodic boundary condition.\n\nReturns\n\nAn N^2×N^2 array representing the coupling matrix of the lattice.\n\nExamples\n\njulia> J = NNlattice(3, 2.0, 1.0)\n9×9 LinearAlgebra.Symmetric{Float64, Matrix{Float64}}:\n 0.0  2.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 2.0  0.0  2.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0\n 1.0  0.0  0.0  0.0  2.0  0.0  1.0  0.0  0.0\n 0.0  1.0  0.0  2.0  0.0  2.0  0.0  1.0  0.0\n 0.0  0.0  1.0  0.0  2.0  0.0  0.0  0.0  1.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  2.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0  2.0  0.0  2.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  2.0  0.0\n\njulia> J_periodic = NNlattice(2, 2.0, 1.0; boundary=:periodic)\n9×9 LinearAlgebra.Symmetric{Float64, Matrix{Float64}}:\n 0.0  2.0  2.0  1.0  0.0  0.0  1.0  0.0  0.0\n 2.0  0.0  2.0  0.0  1.0  0.0  0.0  1.0  0.0\n 2.0  2.0  0.0  0.0  0.0  1.0  0.0  0.0  1.0\n 1.0  0.0  0.0  0.0  2.0  2.0  1.0  0.0  0.0\n 0.0  1.0  0.0  2.0  0.0  2.0  0.0  1.0  0.0\n 0.0  0.0  1.0  2.0  2.0  0.0  0.0  0.0  1.0\n 1.0  0.0  0.0  1.0  0.0  0.0  0.0  2.0  2.0\n 0.0  1.0  0.0  0.0  1.0  0.0  2.0  0.0  2.0\n 0.0  0.0  1.0  0.0  0.0  1.0  2.0  2.0  0.0\n\n\n\n\n\n","category":"function"},{"location":"noise/#Noise","page":"Noise","title":"Noise","text":"","category":"section"},{"location":"noise/","page":"Noise","title":"Noise","text":"Noise\nClassicalNoise\nQuantumNoise\nNoZeroQuantumNoise\nspectrum\npsd","category":"page"},{"location":"noise/#SpiDy.Noise","page":"Noise","title":"SpiDy.Noise","text":"abstract type Noise\n\nAn abstract type used to represent different kinds of environment noise.\n\nAny user-defined subtype of Noise should implement a method noise(::NoiseSubType) which should return a function that represent the spectrum of the noise.\n\n\n\n\n\n","category":"type"},{"location":"noise/#SpiDy.ClassicalNoise","page":"Noise","title":"SpiDy.ClassicalNoise","text":"struct ClassicalNoise{TT<:Real} <: Noise\n\nA subtype of Noise used to represent classical noise, with spectrum\n\nmathcalS(omega) = frack_mathrmBThbaromega\n\nFields\n\nT::TT: The temperature of the environment associated with the noise.\n\n\n\n\n\n","category":"type"},{"location":"noise/#SpiDy.QuantumNoise","page":"Noise","title":"SpiDy.QuantumNoise","text":"struct QuantumNoise{TT<:Real} <: Noise\n\nA subtype of Noise used to represent quantum noise, with spectrum\n\nmathcalS(omega) = cothleft(frachbaromega2k_mathrmBTright)\n\nFields\n\nT::TT: The temperature of the environment associated with the noise.\n\n\n\n\n\n","category":"type"},{"location":"noise/#SpiDy.NoZeroQuantumNoise","page":"Noise","title":"SpiDy.NoZeroQuantumNoise","text":"struct NoZeroQuantumNoise{TT<:Real} <: Noise\n\nA subtype of Noise used to represent quantum noise with zero-point-fluctuations removed, that is with spectrum\n\nmathcalS(omega) = cothleft(frachbaromega2k_mathrmBTright) - 1\n\nFields\n\nT::TT: The temperature of the environment associated with the noise.\n\n\n\n\n\n","category":"type"},{"location":"noise/#SpiDy.spectrum","page":"Noise","title":"SpiDy.spectrum","text":"spectrum(n::ClassicalNoise)\n\nConstruct the spectrum of ClassicalNoise at a given frequency.\n\nArguments\n\nn::ClassicalNoise: The classical noise.\n\nReturns\n\nA function that takes a frequency ω and returns the corresponding spectrum value.\n\n\n\n\n\nspectrum(n::QuantumNoise)\n\nConstruct the spectrum of QuantumNoise at a given frequency.\n\nArguments\n\nn::QuantumNoise: The quantum noise.\n\nReturns\n\nA function that takes a frequency ω and returns the corresponding spectrum value.\n\n\n\n\n\nspectrum(n::NoZeroQuantumNoise)\n\nConstruct the spectrum of NoZeroQuantumNoise at a given frequency.\n\nArguments\n\nn::NoZeroQuantumNoise: The no-zero-point-fluctuations quantum noise.\n\nReturns\n\nA function that takes a frequency ω and returns the corresponding spectrum value.\n\n\n\n\n\n","category":"function"},{"location":"noise/#SpiDy.psd","page":"Noise","title":"SpiDy.psd","text":"function psd(J::GenericSD, noise::Noise)\n\nCalculate the Power Spectral Density (PSD) for a given environment spectral density J and noise model noise.\n\nArguments\n\nJ::GenericSD: The environment spectral density.\nnoise::Noise: The noise model for the environment.\n\nReturns\n\nA function psd(ω) that calculates the PSD at a given frequency ω.\n\n\n\n\n\n","category":"function"},{"location":"stochasticfield/#Stochastic-field","page":"Stochastic field","title":"Stochastic field","text":"","category":"section"},{"location":"stochasticfield/","page":"Stochastic field","title":"Stochastic field","text":"bfield","category":"page"},{"location":"stochasticfield/#SpiDy.bfield","page":"Stochastic field","title":"SpiDy.bfield","text":"bfield(N, Δt, J::GenericSD, noise::Noise; distro=Normal(0., 1/sqrt(Δt)), interpolation=true)\n\nGenerate a stochastic field realisation time series (of length N and spacing Δt) based on the given noise model noise and spectral density J.\n\nArguments\n\nN: The number of time steps.\nΔt: The time step size.\nJ::GenericSD: The environment spectral density.\nnoise::Noise: The noise model for the environment.\ndistro=Normal(0., 1/sqrt(Δt)): (Optional) The distribution of noise samples. Default is a normal distribution with mean 0 and standard deviation 1/sqrt(Δt).\ninterpolation=true: (Optional) Specifies whether to use linear interpolation for the stochastic field time series. Default is true.\n\nReturns\n\nA time series of the stochastic field values.\n\n\n\n\n\n","category":"function"},{"location":"couplingtensor/#Environment-coupling-tensor","page":"Spin-environment coupling tensor","title":"Environment coupling tensor","text":"","category":"section"},{"location":"couplingtensor/","page":"Spin-environment coupling tensor","title":"Spin-environment coupling tensor","text":"Coupling\nAnisoCoupling{TT<:AbstractMatrix{T} where {T<:Real}}\nIsoCoupling{TT<:Real}","category":"page"},{"location":"couplingtensor/#SpiDy.Coupling","page":"Spin-environment coupling tensor","title":"SpiDy.Coupling","text":"abstract type Coupling\n\nAbstract type used to represent different forms of the environment coupling tensor.\n\n\n\n\n\n","category":"type"},{"location":"couplingtensor/#SpiDy.AnisoCoupling","page":"Spin-environment coupling tensor","title":"SpiDy.AnisoCoupling","text":"struct AnisoCoupling{TT<:AbstractMatrix{T} where {T<:Real}} <: Coupling\n\nA subtype of Coupling used to represent generic anisotropic coupling between the spin and environment.\n\nFields\n\nC::TT: The coupling matrix, which must be a 3x3 matrix (of type Matrix{<:Real}).\n\nExamples\n\nFor a system with environment coupling where the y coupling is twice as large as the x, and the z three times as large, one can do:\n\njulia> C = [1.0 0.0 0.0; 0.0 2.0 0.0; 0.0 0.0 3.0]\n3×3 Matrix{Float64}:\n 1.0  0.0  0.0\n 0.0  2.0  0.0\n 0.0  0.0  3.0\n\njulia> coupling = AnisoCoupling(C)\nAnisoCoupling{Matrix{Float64}}([1.0 0.0 0.0; 0.0 2.0 0.0; 0.0 0.0 3.0])\n\nOne can define effective 2D couplings by setting all coefficients in one of the dimensions to zero:\n\njulia> C = [1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 0.0]\n3x3 Matrix{Float64}\n 1.0 0.0 0.0\n 0.0 1.0 0.0\n 0.0 0.0 0.0\n\njulia> coupling_2d = AnisoCoupling(C)\nAnisoCoupling{Matrix{Float64}}([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 0.0])\n\nSimilarly, one can define effective 1D couplings by setting two of the components to zero.\n\n\n\n\n\n","category":"type"},{"location":"couplingtensor/#SpiDy.IsoCoupling","page":"Spin-environment coupling tensor","title":"SpiDy.IsoCoupling","text":"struct IsoCoupling{TT<:Real} <: Coupling\n\nA subtype of Coupling used to represent isotropic coupling between spin and environment.\n\nFields\n\nC::Real: The coupling strength.\n\nExamples\n\njulia> coupling = IsoCoupling(2.5)\nIsoCoupling{Float64}(2.5)\n\n\n\n\n\n","category":"type"},{"location":"dynamics/#Dynamics","page":"Dynamics","title":"Dynamics","text":"","category":"section"},{"location":"dynamics/","page":"Dynamics","title":"Dynamics","text":"diffeqsolver","category":"page"},{"location":"dynamics/#SpiDy.diffeqsolver","page":"Dynamics","title":"SpiDy.diffeqsolver","text":"function diffeqsolver(s0, tspan, J::LorentzianSD, Jshared::LorentzianSD, bfields, bfieldshared, matrix::Coupling; JH=zero(I), S0=1/2, Bext=[0, 0, 1], saveat=[], projection=true, alg=Tsit5(), atol=1e-3, rtol=1e-3)\n\nSolves the dynamics of a system of ineracting spins under the influence of both local (unique to each spin) and global (shared by all spins) stochastic noise from the environment.\n\nArguments\n\ns0: Array of length 3N specifying the initial conditions of the N spins. The order the initial consitions is first the Sx,Sy,Sz for the first spin, then for the second, and so on.\ntspan: The time span to solve the equations over, specified as a tuple (tstart, tend).\nJ::LorentzianSD: The spectral density of the noise acting locally (i.e. independently) on each spin.\nJshared::LorentzianSD: The spectral density of the noise acting globally on all spins.\nbfields: An array of tuples of functions Array{Tuple{Function, Function, Function}} representing the time series of the local stochastic field for each spin.\nbfieldshared: A tuple of functions Tuple{Function, Function, Function} representing the time series of the global stochastic field shared by all the spins.\nmatrix::Coupling: The spin-environment coupling matrix.\nJH=zero(I): (Optional) The spin-spin coupling matrix. Default is zero matrix (i.e. non-interacting spins).\nS0=1/2: (Optional) The spin quantum number. Default is 1/2.\nBext=[0, 0, 1]: (Optional) The external magnetic field vector. Default is [0, 0, 1] (normalised length pointing in the z direction).\nsaveat=[]: (Optional) An array of time points where the solution should be saved. Default is empty, which saves the solution at the time steps chosen by the integration algorithm.\nprojection=true: (Optional) Specifies whether to project the spin vectors onto the unit sphere at each time step, hence forcing the numerical conservation of the spin length. Default is true.\nalg=Tsit5(): (Optional) The differential equation solver algorithm. Default is Tsit5(). See the DifferentialEquations.jl docs for choices.\natol=1e-3: (Optional) The absolute tolerance for the solver. Default is 1e-3.\nrtol=1e-3: (Optional) The relative tolerance for the solver. Default is 1e-3.\n\nReturns\n\nAn ODESolution struct from DifferentialEquations.jl containing the solution of the equations of motion.\n\n\n\n\n\nfunction diffeqsolver(s0, tspan, J::LorentzianSD, Jshared::LorentzianSD, bfields, bfieldshared, matrix::Coupling; JH=zero(I), S0=1/2, Bext=[0, 0, 1], saveat=[], projection=true, alg=Tsit5(), atol=1e-3, rtol=1e-3)\n\nSolves the dynamics of a system of ineracting spins under the influence of either local (unique to each spin) or global (shared by all spins) stochastic noise from the environment.\n\nArguments\n\ns0: Array of length 3N specifying the initial conditions of the N spins. The order the initial consitions is first the Sx,Sy,Sz for the first spin, then for the second, and so on.\ntspan: The time span to solve the equations over, specified as a tuple (tstart, tend).\nJ::LorentzianSD: The spectral density of the noise acting on the spins (either local or shared depending on the value of bfields).\nbfields: For local baths, an array of tuples of functions Array{Tuple{Function, Function, Function}} representing the time series of the local stochastic field for each spin. For a global bath, a tuple of functions Tuple{Function, Function, Function} representing the time series of the global stochastic field shared by all the spins.\nmatrix::Coupling: The spin-environment coupling matrix.\nJH=zero(I): (Optional) The spin-spin coupling matrix. Default is zero matrix (i.e. non-interacting spins).\nS0=1/2: (Optional) The spin quantum number. Default is 1/2.\nBext=[0, 0, 1]: (Optional) The external magnetic field vector. Default is [0, 0, 1] (normalised length pointing in the z direction).\nsaveat=[]: (Optional) An array of time points where the solution should be saved. Default is empty, which saves the solution at the time steps chosen by the integration algorithm.\nprojection=true: (Optional) Specifies whether to project the spin vectors onto the unit sphere at each time step, hence forcing the numerical conservation of the spin length. Default is true.\nalg=Tsit5(): (Optional) The differential equation solver algorithm. Default is Tsit5(). See the DifferentialEquations.jl docs for choices.\natol=1e-3: (Optional) The absolute tolerance for the solver. Default is 1e-3.\nrtol=1e-3: (Optional) The relative tolerance for the solver. Default is 1e-3.\n\nReturns\n\nAn ODESolution struct from DifferentialEquations.jl containing the solution of the equations of motion.\n\n\n\n\n\nfunction diffeqsolver(s0, tspan, J::LorentzianSD, Jshared::LorentzianSD, bfields, bfieldshared, matrix::Coupling; JH=zero(I), S0=1/2, Bext=[0, 0, 1], saveat=[], projection=true, alg=Tsit5(), atol=1e-3, rtol=1e-3)\n\nSolves the dynamics of a system of ineracting spins under the influence of either local (unique to each spin) or global (shared by all spins) stochastic noise from the environment.\n\nArguments\n\nx0: Array of length N specifying the initial position of the N oscillators.\np0: Array of length N specifying the initial momentum of the N oscillators.\ntspan: The time span to solve the equations over, specified as a tuple (tstart, tend).\nJ::LorentzianSD: The spectral density of the noise acting globally on the harmonic oscillators.\nbfields: A tuple of functions Tuple{Function, Function, Function} representing the time series of the global stochastic field shared by all the harmonic oscillators.\nmatrix::Coupling: The harmonic oscillators-environment coupling matrix.\nJH=zero(I): (Optional) The oscillator-oscillator coupling matrix. Default is zero matrix (i.e. non-interacting oscillators).\nΩ=1: (Optional) The natural angular frequency of the harmonic oscillators (currently the same for all). Default is 1.\nsaveat=[]: (Optional) An array of time points where the solution should be saved. Default is empty, which saves the solution at the time steps chosen by the integration algorithm.\nprojection=true: (Optional) Specifies whether to project the spin vectors onto the unit sphere at each time step, hence forcing the numerical conservation of the spin length. Default is true.\nalg=Tsit5(): (Optional) The differential equation solver algorithm. Default is Tsit5(). See the DifferentialEquations.jl docs for choices.\natol=1e-3: (Optional) The absolute tolerance for the solver. Default is 1e-3.\nrtol=1e-3: (Optional) The relative tolerance for the solver. Default is 1e-3.\n\nReturns\n\nAn ODESolution struct from DifferentialEquations.jl containing the solution of the equations of motion.\n\n\n\n\n\n","category":"function"},{"location":"spectraldensity/#Spectral-density","page":"Spectral density","title":"Spectral density","text":"","category":"section"},{"location":"spectraldensity/","page":"Spectral density","title":"Spectral density","text":"GenericSD\nLorentzianSD\nPolySD\nsd(J::GenericSD)\nsdoverω(J::GenericSD)\nsdoverω(J::LorentzianSD)\nsd(J::PolySD)\nreorgenergy(J::GenericSD)\nreorgenergy(J::LorentzianSD)\nkernel(J::LorentzianSD)\nimagkernel(J::GenericSD)","category":"page"},{"location":"spectraldensity/#SpiDy.GenericSD","page":"Spectral density","title":"SpiDy.GenericSD","text":"GenericSD\n\nDefinition of the abstract type GenericSD.\n\n\n\n\n\n","category":"type"},{"location":"spectraldensity/#SpiDy.LorentzianSD","page":"Spectral density","title":"SpiDy.LorentzianSD","text":"LorentzianSD{T<:Real}\n\nReturns a LorentzianSD structure of type GenericSD built by passing 3 Real values. The values are ordered as LorentzianSD(α, ω0, Γ).\n\nExamples\n\njulia> LorentzianSD(1., 3., 8.)\n\n\n\n\n\n","category":"type"},{"location":"spectraldensity/#SpiDy.PolySD","page":"Spectral density","title":"SpiDy.PolySD","text":"PolySD{T<:Real}\n\nReturns a PolySD structure of type GenericSD built by passing 3 Real values. The values are ordered as PolySD(s, α, ωcut).\n\nExamples\n\njulia> PolySD(1., 3., 100.)\n\n\n\n\n\n","category":"type"},{"location":"spectraldensity/#SpiDy.sd-Tuple{GenericSD}","page":"Spectral density","title":"SpiDy.sd","text":"sd(J::GenericSD)\n\nDefines the spectral density for generic shapes GenericSD. The returned function depends on ω.\n\n\n\n\n\n","category":"method"},{"location":"spectraldensity/#SpiDy.sdoverω-Tuple{GenericSD}","page":"Spectral density","title":"SpiDy.sdoverω","text":"sdoverω(J::GenericSD)\n\nReturns the spectral density divided by ω for generic shapes GenericSD. The returned function depends on ω.\n\n\n\n\n\n","category":"method"},{"location":"spectraldensity/#SpiDy.sdoverω-Tuple{LorentzianSD}","page":"Spectral density","title":"SpiDy.sdoverω","text":"sdoverω(J::LorentzianSD)\n\nReturns the spectral density divided by ω for LorentzianSD shapes which naturally defines sd(J::LorentzianSD). The returned function depends on ω.\n\n\n\n\n\n","category":"method"},{"location":"spectraldensity/#SpiDy.sd-Tuple{PolySD}","page":"Spectral density","title":"SpiDy.sd","text":"sdoverω(J::PolySD)\n\nReturns the spectral density for PolySD shapes with exponential cut-off which naturally defines sdoverω(J::PolySD). The returned function depends on ω.\n\n\n\n\n\n","category":"method"},{"location":"spectraldensity/#SpiDy.reorgenergy-Tuple{GenericSD}","page":"Spectral density","title":"SpiDy.reorgenergy","text":"reorgenergy(J::GenericSD)\n\nReturns the reorganization energy numerically integrated as int_0^infty textsdoverω(omega)domega.\n\n\n\n\n\n","category":"method"},{"location":"spectraldensity/#SpiDy.reorgenergy-Tuple{LorentzianSD}","page":"Spectral density","title":"SpiDy.reorgenergy","text":"reorgenergy(J::LorentzianSD)\n\nReturns the analytical reorganization energy for LorentzianSD shapes.\n\n\n\n\n\n","category":"method"},{"location":"spectraldensity/#SpiDy.kernel-Tuple{LorentzianSD}","page":"Spectral density","title":"SpiDy.kernel","text":"kernel(J::LorentzianSD)\n\nReturns the specific damping kernel for a Lorentzian spectral density defined by the parameters in J. The returned function depends on ω.\n\n\n\n\n\n","category":"method"},{"location":"spectraldensity/#SpiDy.imagkernel-Tuple{GenericSD}","page":"Spectral density","title":"SpiDy.imagkernel","text":"imagkernel(J::GenericSD)\n\nReturns the imaginary part of the damping kernel for a Generic spectral density real and anti-symmetric in ω. Of this kind, we find Lorentzian spectral densities, and Polynomial spectral densities with sinmathbbN. The spectral density is defined by the parameters in J. The returned function depends on ω.\n\n\n\n\n\n","category":"method"},{"location":"#SpiDy.jl-documentation","page":"Start with SpiDy.jl","title":"SpiDy.jl documentation","text":"","category":"section"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"pages = [\"Start with SpiDy.jl\" => \"index.md\",\n         \"Noise\" => \"noise.md\",\n         \"Spectral density\" => \"spectraldensity.md\",\n         \"Stochastic field\" => \"stochasticfield.md\",\n         \"Spin-environment coupling tensor\" => \"couplingtensor.md\",\n         \"Spin-spin interactions\" => \"couplingfunctions.md\",\n         \"Dynamics\" => \"dynamics.md]","category":"page"},{"location":"#Start-with-SpiDy.jl","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"","category":"section"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"SpiDy.jl is a Spin-Dynamics Julia package. The code is a generalization of the results obtained in the paper \"Quantum Brownian motion for magnets\" to account for arbitrary dimensional system-bath coupling. The system considered is a quantized three-dimensional spin + environment Hamiltonian. The code solves a set of differential equations for the spin vector where the damping accounts for memory, arbitrary noise and arbitrary statistics.","category":"page"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"The classical simulations in anisotropic coupling found in the pre-print \"Quantum-classical correspondence in spin-boson equilibrium states at arbitrary coupling\" have been generated using a very-early-version of this code.","category":"page"},{"location":"#Install-Julia","page":"Start with SpiDy.jl","title":"Install Julia","text":"","category":"section"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"If you are new to Julia, here is how to install it.","category":"page"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"If you are a Windows/Mac user, download Julia here and run the installer. On Mac, drag-and-drop the app to the Applications.","category":"page"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"If you are a Linux user, just open a terminal and use your package manager, e.g. on Debian-based distros run \"sudo apt-get install julia\", on RedHat-based distros run \"sudo dnf install julia\".","category":"page"},{"location":"#Install-SpiDy.jl","page":"Start with SpiDy.jl","title":"Install SpiDy.jl","text":"","category":"section"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"Following the Julia General Registry guidelines, the package can be installed as follows. (NB: the entire installation of SpiDy and its dependencies takes about 5 minutes on a bare-bones Julia environment.)","category":"page"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"Start Julia and enter in Pkg REPL mode by pressing ] then run the following,","category":"page"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"add https://github.com/quantum-exeter/SpiDy.jl","category":"page"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"or alternatively run the following lines in your code,","category":"page"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"using Pkg;\nPkg.add(url=\"https://github.com/quantum-exeter/SpiDy.jl\")","category":"page"},{"location":"#Run-SpiDy.jl","page":"Start with SpiDy.jl","title":"Run SpiDy.jl","text":"","category":"section"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"To run the code,","category":"page"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"save run_dynamics.jl and run_steadystate.jl in your preferred location (right click -> save as... should work to save the file)\nopen the terminal or command line\nrun the following command,","category":"page"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"julia \"path-to-your-file\"/run_dynamics.jl","category":"page"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"where \"path-to-your-file\" is the one where you saved your file. Replace run_dynamics.jl with run_steadystate.jl to run the one of your choice.","category":"page"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"NB: the code can exploit parallel computation. To do this, run your files as","category":"page"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"julia -t 6 \"path-to-your-file\"/run_dynamics.jl","category":"page"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"where you want to replace \"6\" with the number of threads that you wish to use. As a general idea, you do not want to use more than 80% of the number of threads you have available in your machine, e.g. if you have a 4-core CPU, you are likely to have 8 threads and you may want to run the parallelization as indicated above.","category":"page"},{"location":"#Index","page":"Start with SpiDy.jl","title":"Index","text":"","category":"section"},{"location":"","page":"Start with SpiDy.jl","title":"Start with SpiDy.jl","text":"","category":"page"}]
}
